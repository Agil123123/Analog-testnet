"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.keygen = void 0;
const timegraph_wasm_1 = require("@analog-labs/timegraph-wasm");
class keygen {
    /**
     * Creates a new ```Keygen``` instance.
     * @param { IKeyringPair["sign"] } args.signer the polkadot keyring keypair interface {@link https://www.npmjs.com/package/@polkadot/kering IKeyringPair["sign"]} keypair sign type is required.
     * @param {types.string} args.address the substrate wallet address used for authentication.
     * @returns {Keygen} a new keygen instance.
     *
     * ```
     * import Keyring from "@polkadot/keyring";
     * import { cryptoWaitReady } from "@polkadot/util-crypto";
     * import { Keygen } from "analog-js/timegraph-js";
     *
     * await cryptoWaitReady();
     *
     * const keyring = new Keyring({ type: "sr25519" });
     *
     * const keyparir = keyring.add...();
     *
     * const _keygen = new Keygen({ signer: keypair.sign, address: keypair.address });
     *
     * ```
     */
    constructor({ signer, address }) {
        this._signer = signer;
        this._address = address;
    }
    /**
     * Creates a new ```GeneratedApiKey```.
     * @param {role} args.role the role for the user in timegraph i.e developer, collector, user
     * @returns {Promise<GeneratedApiKey>} a new generated api key
     */
    createApiKey(role = 'developer') {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const sign = this._signer;
                if (sign) {
                    const [cert, secret] = (0, timegraph_wasm_1.new_cert)(this._address, role);
                    const signedData = sign(cert);
                    const key = (0, timegraph_wasm_1.build_apikey)(secret, cert, signedData);
                    return key;
                }
                throw new Error('Error while initiating signer');
            }
            catch (e) {
                throw Error(`Error while creating Api Key ${e}`);
            }
        });
    }
    /**
     * Creates a new ```GeneratedSessionKey```.
     * @param {expiration} args.expiration the expiration time in ms of the session key
     * @returns {Promise<GeneratedSessionKey>} a new generated session key
     */
    createSessionkey(expiration = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const sign = this._signer;
                if (sign) {
                    const ssk_data = (0, timegraph_wasm_1.encode_ssk)({
                        ns: 0,
                        key: this._address,
                        user_id: 1,
                        expiration: expiration,
                    });
                    const sskSignature = sign(stringToU8a(ssk_data));
                    const ssk = (0, timegraph_wasm_1.build_ssk)(ssk_data, sskSignature);
                    return { ssk };
                }
                throw new Error('Error while initiating signer');
            }
            catch (e) {
                throw Error(`Error while creating Session Key ${e}`);
            }
        });
    }
}
exports.keygen = keygen;
function stringToU8a(inputString) {
    const u8a = new Uint8Array(inputString.length);
    for (let i = 0; i < inputString.length; i++) {
        u8a[i] = inputString.charCodeAt(i);
    }
    return u8a;
}
