"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.keygen = void 0;
const lib_1 = __importStar(require("@analog-labs/timegraph-wasm/web/lib"));
(0, lib_1.default)();
class keygen {
    /**
     * Creates a new ```Keygen``` instance.
     * @param {Signer["signRaw"]  } args.signer the polkadot Signer interface {@link https://www.npmjs.com/package/@polkadot/extension-dapp Signer['signRaw']} injector signer interface is required.
     * @param {types.string} args.address the substrate wallet address used for authentication.
     * @returns {Keygen} a new keygen instance.
     *
     * ```
     * import { web3FromSource, web3Enable, web3Accounts } from "@polkadot/extension-dapp";
     * import { keygen } from "@analog-labs/timegraph-js/keygen/web";
     *
     * await web3Enable();
     *
     * const accounts = await web3Accounts();
     *
     * await web3 = await web3FromSource();
     *
     * const _keygen = new keygen({ signer: web3.signer.signRaw, address: accounts[0].address });
     *
     * ```
     */
    constructor({ signer, address }) {
        this._signer = signer;
        this._address = address;
    }
    /**
     * Creates a new ```GeneratedApiKey```.
     * @param {role} args.role the role for the user in timegraph i.e developer, collector, user
     * @returns {Promise<GeneratedApiKey>} a new generated api key
     */
    createApiKey(role = 'developer') {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const signRaw = this._signer;
                if (signRaw) {
                    const [cert, secret] = (0, lib_1.new_cert)(this._address, role);
                    const signedData = yield signRaw({
                        address: this._address,
                        data: cert,
                        type: 'bytes',
                    });
                    const key = (0, lib_1.build_apikey)(secret, cert, hexToU8a(signedData.signature));
                    return key;
                }
                throw new Error('Error while initiating signer');
            }
            catch (e) {
                throw Error(`Error while creating Api Key ${e}`);
            }
        });
    }
    /**
     * Creates a new ```GeneratedSessionKey```.
     * @param {expiration} args.expiration the expiration time in ms of the session key
     * @returns {Promise<GeneratedSessionKey>} a new generated session key
     */
    createSessionkey(expiration = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const signRaw = this._signer;
                if (signRaw) {
                    const ssk_data = (0, lib_1.encode_ssk)({
                        ns: 0,
                        key: this._address,
                        user_id: 1,
                        expiration: expiration,
                    });
                    const sskSignature = yield signRaw({
                        address: this._address,
                        data: ssk_data,
                        type: 'bytes',
                    });
                    const ssk = (0, lib_1.build_ssk)(ssk_data, hexToU8a(sskSignature.signature));
                    return { ssk };
                }
                throw new Error('Error while initiating signer');
            }
            catch (e) {
                throw Error(`Error while creating Session Key ${e}`);
            }
        });
    }
}
exports.keygen = keygen;
function hexToU8a(hexString) {
    // Remove the "0x" prefix if present
    hexString = hexString.startsWith("0x") ? hexString.slice(2) : hexString;
    // Check if the input is a valid hexadecimal string
    if (!/^(0x)?[0-9A-Fa-f]*$/.test(hexString)) {
        throw new Error("Invalid hexadecimal string");
    }
    // Create a new Uint8Array from the hexadecimal string
    const u8a = new Uint8Array(hexString.length / 2);
    for (let i = 0; i < hexString.length; i += 2) {
        u8a[i / 2] = parseInt(hexString.slice(i, i + 2), 16);
    }
    return u8a;
}
