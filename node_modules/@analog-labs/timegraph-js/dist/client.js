"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimegraphClient = void 0;
const graphql_request_1 = require("graphql-request");
const graphql_tag_1 = __importDefault(require("graphql-tag"));
const g = __importStar(require("./gql"));
function getHeaders(...headerSets) {
    return headerSets.reduce((merged, headers) => {
        let additions = {};
        if (!headers) {
            return merged;
        }
        if (headers instanceof Headers) {
            headers.forEach((v, k) => {
                additions[k.toLowerCase()] = v;
            });
        }
        else if (Array.isArray(headers)) {
            headers.forEach(([k, v]) => {
                additions[k.toLowerCase()] = v;
            });
        }
        else {
            additions = Object.entries(headers).reduce((res, [k, v]) => (Object.assign(Object.assign({}, res), { [k.toLowerCase()]: v })), {});
        }
        return Object.assign(Object.assign({}, merged), additions);
    }, {});
}
const IDENTITY = (res) => res;
class TimegraphClient {
    /**
     * Creates a new ```TimegraphClient``` instance.
     * @param {types.TimegraphClientOptions['url']} args.url the timegraph URL
     * @param {types.TimegraphClientOptions['sessionKey']} args.sessionKey a valid session key for the timegraph. This key is passed in the ```Authorization``` header for all subsequent requests.
     * @returns {TimegraphClient} a new TimegraphClient instance
     */
    constructor({ url, sessionKey }) {
        this.user = {
            /**
             * Create a new user account with the provided wallet address.
             * @param {g.UserCreateMutationVariables} args arguments
             * @param {g.UserCreateMutationVariables['address']} args.address the new account's wallet address
             * @returns {types.UserCreate} the created user's information
             */
            create: this.request('userCreate', ({ createAccount }) => createAccount),
            /**
             * Fetch the current user's information. The current user is determined by the session key passed in the ```Authorization``` header.
             * @returns {types.UserGet} the current user's information
             */
            get: this.request('userGet', ({ userInfo }) => userInfo),
            /**
             * Fetch a list of registered users from the global namespace.
             * @returns {types.UserList} an array of ```UserInfo``` objects
             */
            list: this.request('userList', ({ users }) => users),
        };
        this.tokenomics = {
            /**
             * Withdraw Tokens from tokenomics account
             * @param {g.WithdrawTokensMutationVariables["amount"]} args.amount amount of tokens to withdraw
             * @returns {string} success/failed message response
             */
            widthdraw: this.request('withdrawTokens', ({ withdrawToken }) => withdrawToken),
            /**
             * Withdraw Tokens from tokenomics account
             * @param {g.SponsorViewMutationVariables["viewName"]} args.viewName name of view to sponsor
             * @param {g.SponsorViewMutationVariables["amount"]} args.amount amount to sponsor
             * @returns {string} success/failed message response
             */
            sponsorView: this.request('sponsorView', ({ sponsorView }) => sponsorView),
        };
        this.telemetry = {
            global: this.request('GlobalStats', ({ global }) => global),
            user: this.request('UserStats', ({ global }) => global),
            userGraph: this.request('UserGraph', ({ global }) => global),
            balanceHistory: this.request('BalanceHistory', ({ global }) => global),
            ssk: this.request('SSKStats', ({ global }) => global),
            sskGraph: this.request('SSKGraph', ({ global }) => global),
            view: this.request('ViewStats', ({ global }) => global),
            viewGraph: this.request('ViewGraph', ({ global }) => global),
            viewFundLog: this.request('ViewFundLog', ({ global }) => global),
            userFundedViews: this.request('UserFundedViews', ({ global }) => global),
            totalContracts: this.request('TotalContracts', ({ global }) => global),
            totalViews: this.request('TotalViews', ({ global }) => global),
        };
        this.apiKey = {
            /**
             * List the current user's API keys. The current user is determined by the session key in the request's ```Authorization``` header.
             * @returns {types.ApiKeyList} an array of ```KeyInfo``` objects
             */
            list: this.request('apiKeyList', ({ keys }) => keys),
            /**
             * Certify the certificate data for a new API key and save it in storage. You must pass a valid session key for the signing account in the ```Authorization``` header:
             *
             * ```
             * await timegraph.apiKey.certify({ cert: '...' }, new Headers({ Authorization: '...' }));
             * ```
             * @param {types.ApiKeyCertifyMutationVariables} args arguments
             * @param { types.ApiKeyCertifyMutationVariables['cert']} args.cert the API key's certificate data as a string
             * @returns {types.ApiKeyInfoFragment} the created key's ```KeyInfo```
             */
            certify: this.request('apiKeyCertify', ({ certifyKey }) => certifyKey),
            /**
             * Disable an API key. You must pass a valid session key for the key's owner in the ```Authorization``` header:
             *
             * ```
             * await timegraph.apiKey.enable({ key: '...' }, new Headers({ Authorization: '...' }));
             * ```
             * @param {types.ApiKeyDisableMutationVariables} args
             * @param { types.ApiKeyDisableMutationVariables['key']} args.key the API key's public key
             * @returns {types.ApiKeyInfoFragment} the enabled key's ```KeyInfo```
             */
            disable: this.request('apiKeyDisable', ({ disableKey }) => disableKey),
            /**
             * Enable a previously disabled API key. You must pass a valid session key for the key's owner in the ```Authorization``` header:
             *
             * ```
             * await timegraph.apiKey.enable({ key: '...' }, new Headers({ Authorization: '...' }));
             * ```
             * @param {types.ApiKeyEnableMutationVariables} args
             * @param { types.ApiKeyEnableMutationVariables['key']} args.key the API key's public key
             * @returns {types.ApiKeyInfoFragment} the enabled key's ```KeyInfo```
             */
            enable: this.request('apiKeyEnable', ({ enableKey }) => enableKey),
            /**
             * Permanently disable an API key. You must pass a valid session key for the key's owner in the ```Authorization``` header:
             *
             * ```
             * await timegraph.apiKey.revoke({ key: '...' }, new Headers({ Authorization: '...' }));
             * ```
             * @param {types.ApiKeyRevokeMutationVariables} args
             * @param { types.ApiKeyRevokeMutationVariables['key']} args.key the API key's public key
             * @returns {types.ApiKeyInfoFragment} the revoked key's ```KeyInfo```
             */
            revoke: this.request('apiKeyRevoke', ({ revokeKey }) => revokeKey),
        };
        this.fn = {
            /**
             * Publish a set of functions to the timegraph
             * @param {g.FunctionSpec[]} specs an array of ```FunctionSpec``` objects
             * @returns {types.FnCreate} an array of successfully created FunctionInfo objects, or ```null``` if unsuccessful. For advanced error handling use ```timegraph.raw.fn.create(...)```
             */
            create: this.request('functionCreate', ({ merge }) => {
                if (merge.status === 'Completed') {
                    return merge.functions
                        .filter((fn) => !fn.error && !!fn.function)
                        .map(({ function: fn }) => fn);
                }
                return null;
            }),
            /**
             * Fetch a single function by its hash ID, or throw an error if not found
             * @param {g.FunctionGetQueryVariables['hashId']} args.hashId the hash ID of the desired function
             * @returns {types.FnGet} the retrieved view information
             */
            get: this.request('functionGet', ({ global: { functions } }, variables) => {
                if (functions[0] && variables[0] && functions[0].hashId === variables[0].hash) {
                    return functions[0];
                }
                throw new ReferenceError('Function not found');
            }),
            /**
             * Fetch several functions from the timegraph's global interface at once
             * @param {g.FunctionGlobalQueryVariables['after']} args.after fetch only functions more recent than this hash ID
             * @param {g.FunctionGlobalQueryVariables['before']} args.before fetch only functions older than this hash ID
             * @param {g.FunctionGlobalQueryVariables['limit']} args.limit limit result set to this amount
             * @param {g.FunctionGlobalQueryVariables['hash']} args.hash retrieve only functions with this hash ID. Alternatively, use ```timegraph.fn.get({ hashId: ... })```
             * @returns {types.FnList} an array of matching functions
             */
            global: this.request('functionGlobal', ({ global: { functions } }) => functions),
            /**
             * Fetch several functions from the current user's namespace at once
             * @param {g.FunctionSubgraphQueryVariables['after']} args.after fetch only functions more recent than this hash ID
             * @param {g.FunctionSubgraphQueryVariables['before']} args.before fetch only functions older than this hash ID
             * @param {g.FunctionSubgraphQueryVariables['limit']} args.limit limit result set to this amount
             * @param {g.FunctionSubgraphQueryVariables['hash']} args.hash retrieve only functions with this hash ID. Alternatively, use ```timegraph.fn.get({ hashId: ... })```
             * @returns {types.FnList} an array of matching functions
             */
            subgraph: this.request('functionSubgraph', ({ subgraph: { functions } }) => functions),
        };
        this.smartContract = {
            /**
             * Publish a set of Smartcontract and functions to the timegraph
             * @param {g.MutationContractArgs["address"]}  args.address the address of the desired smart contract
             * @param {g.MutationContractArgs["network"]}  args.network the network of the desired smart contract
             * @param {g.MutationContractArgs["chain"]}  args.chain  the chain i.e mainnet, testnet of the desired smart contract
             * @param {g.MutationContractArgs["identifier"]}  args.Identifier the identifier for functions of the desired smart contract
             * @param {g.MutationContractArgs["methods"]}  args.methods the methods of the desired smart contract
             * @param {g.MutationContractArgs["scope"]}  args.scope the scope  of the desired smart contract i.e subgraph, local
             * @returns {types.ListSmartContract} an array of ```MergeResult``` objects. For advanced error handling, use ```timegraph.raw.view.create(...)```
             */
            list: this.request('listSmartContract', ({ contract }) => contract),
            /**
             * Publish a set of Smartcontract and functions to the timegraph
             * @param {g.MutationContractArgs["address"]}  args.address the address of the desired smart contract
             * @param {g.MutationContractArgs["network"]}  args.network the network of the desired smart contract
             * @param {g.MutationContractArgs["chain"]}  args.chain  the chain i.e mainnet, testnet of the desired smart contract     * @param {g.MutationContractArgs["identifier"]}  args.address the address of the desired smart contract
             * @param {g.MutationContractArgs["methods"]}  args.methods the methods of the desired smart contract
             * @returns {types.DryRunListSmartContract} an array of ```MergeResult``` objects. For advanced error handling, use ```timegraph.raw.view.create(...)```
             */
            dryRun: this.request('dryRunListSmartContract', ({ contract }) => contract),
            /**
             * Fetch a single smart contract by its on-chain address, or throw an error if not found
             * @param {g.SmartContractGetQueryVariables['address']} args.address the address of the desired smart contract
             * @returns {types.SmartContractGet} the retrieved smart contract information
             */
            get: this.request('smartContractGet', ({ global: { contracts } }, variables) => {
                if (contracts[0] && variables[0] && contracts[0].address === variables[0].address) {
                    return contracts[0];
                }
                throw new ReferenceError('Smart contract not found');
            }),
            /**
             * Fetch several smart contracts from the timegraph at once
             * @param {g.SmartContractGlobalQueryVariables['after']} args.after fetch only smart contracts more recent than this hash ID
             * @param {g.SmartContractGlobalQueryVariables['before']} args.before fetch only views older than this hash ID
             * @param {g.SmartContractGlobalQueryVariables['network']} args.network fetch only smart contracts on this network (e.g. ```ethereum```)
             * @param {g.SmartContractGlobalQueryVariables['address']} args.address retrieve only results with this address. Alternatively, use ```timegraph.smartContract.get({ address: ... })```
             * @returns {types.SmartContractGlobal} an array of matching smart contracts
             */
            global: this.request('smartContractGlobal', ({ global: { contracts } }) => contracts),
        };
        this.view = {
            /**
             * Publish a set of views to the timegraph
             * @param {g.ViewSpec[]} specs an array of ViewSpec objects
             * @returns {types.ViewCreate} an array of ```MergeResult``` objects. For advanced error handling, use ```timegraph.raw.view.create(...)```
             */
            create: this.request('viewCreate', ({ merge }) => {
                const result = merge.views.map(({ view: v, status, error }) => {
                    return {
                        status: status === 'Untouched' ? 'DUPLICATE' : error ? 'ERROR' : 'SUCCESS',
                        error: error || undefined,
                        result: v,
                    };
                });
                return result;
            }),
            /**
             * Execute a dry run on a potential ```ViewSpec``` object to sample the returned data.
             * @param {g.ViewSpec[]} view an array of ViewSpec objects to test
             * @returns {types.ViewDryRun} an array of successful ```ViewMergeResult``` objects, with accompanying ```QueryResult```
             */
            dryRun: this.request('viewDryRun', ({ merge }) => {
                return merge.views;
            }),
            /**
             * Fetch a single view by its hash ID, or throw an error if not found
             * @param {g.ViewGetQueryVariables['hashId']} args.hashId the hash ID of the desired view
             * @returns {types.ViewGet} the retrieved view information
             */
            get: this.request('viewGet', ({ global: { views } }, variables) => {
                if (views[0] && variables[0] && views[0].hashId === variables[0].hashId) {
                    return views[0];
                }
                throw new ReferenceError('View not found');
            }),
            /**
             * Fetch several views from the timegraph at once
             * @param {g.ViewGlobalQueryVariables['after']} args.after fetch only views more recent than this hash ID
             * @param {g.ViewGlobalQueryVariables['before']} args.before fetch only views older than this hash ID
             * @param {g.ViewGlobalQueryVariables['limit']} args.limit limit results set to this amount
             * @param {g.ViewGlobalQueryVariables['hash']} args.hash retrieve only results with this hash ID. Alternatively, use ```timegraph.view.get({ hashId: ... })```
             * @returns {types.ViewGlobal} an array of matching views
             */
            global: this.request('viewGlobal', ({ global: { views } }) => views),
            /**
             * Fetch several views from the current user's namespace at once
             * @param {g.ViewSubgraphQueryVariables['after']} args.after fetch only views more recent than this hash ID
             * @param {g.ViewSubgraphQueryVariables['before']} args.before fetch only views older than this hash ID
             * @param {g.ViewSubgraphQueryVariables['limit']} args.limit limit result set to this amount
             * @param {g.ViewSubgraphQueryVariables['hash']} args.hash retrieve only views with this hash ID. Alternatively, use ```timegraph.view.get({ hashId: ... })```
             * @returns {types.ViewSubgraph} an array of matching Views
             */
            subgraph: this.request('viewSubgraph', ({ subgraph: { views } }) => views),
            /**
             * Fetch stored data from a desired view
             * @param {types.DataArgs['hashId']} args.hashId the desired view's hash ID
             * @param {types.DataArgs['fields']} args.fields the field (column) names to include with each record. ```_clock``` and ```_index``` fields are always included.
             * @param {types.DataArgs['limit']} args.limit limit result set to this amount
             * @returns {T[]} the retrieved view data
             */
            data: ({ hashId, fields, limit = 10 }) => __awaiter(this, void 0, void 0, function* () {
                const view = yield this.view.get({ hashId });
                if (view === null || view === void 0 ? void 0 : view.name) {
                    const result = yield this.client.request({
                        document: (0, graphql_tag_1.default) `
            query {
              collection {
                ${view.name}(limit: ${limit}) {
                  ${fields.join('\n')}
                }
              }
            }
          `,
                        requestHeaders: new Headers({ Authorization: this._sessionKey }),
                    });
                    return result.collection[view.name];
                }
                throw new Error(`Unable to fetch data for hashId ${hashId}`);
            }),
        };
        /**
         * Globally fetch stored data from a desired  view
         * @param {types.DataQueryVariables['identifier']} args.identifier. the desired  view's hashId, or global identifier
         * @param {types.DataQueryVariables['limit']} args.limit limit result set to this amount
         * @param {types.DataQueryVariables['before']} args.before fetch data only before this cycle
         * @param {types.DataQueryVariables['after']} args.after fetch data only after this cycle
         * @returns {types.QueryResult} the retrieved query data
         */
        this.data = this.request('data', ({ global }) => global.query);
        this.alias = {
            /**
             * Alias a function, or view from another user to the current user's own subgraph.
             * @param {types.AliasMutationVariables['identifier']} args.identifier the hashId of the desired artifact
             * @param {types.AliasMutationVariables['name']} args.name the unique string identifier that will be used for the artifact in the user's subgraph
             * @returns {types.AliasResult} the ```AliasResult``` including the operation's status and the newly aliased resource
             */
            add: this.request('aliasAdd', ({ alias }) => alias),
            /**
             * Remove a previously added alias from the current user's subgraph
             * @param {types.AliasMutationVariables['name']} args.name the aliased name of the artifact to be removed
             * @returns {types.AliasResult} the ```AliasResult``` including the operation's status and the just-removed artifact
             */
            remove: this.request('aliasRemove', ({ drop }) => drop),
        };
        /**
         * Accessors for performing queries and returning the raw GraphQL responses, without any destructuring helpers applied
         */
        this.raw = {
            user: {
                create: this.request('userCreate', IDENTITY),
                get: this.request('userGet', IDENTITY),
                list: this.request('userList', IDENTITY),
            },
            fn: {
                create: this.request('functionCreate', IDENTITY),
                get: this.request('functionGet', IDENTITY),
                global: this.request('functionGlobal', IDENTITY),
                subgraph: this.request('functionSubgraph', IDENTITY),
            },
            smartContract: {
                get: this.request('smartContractGet', IDENTITY),
                global: this.request('smartContractGlobal', IDENTITY),
            },
            view: {
                create: this.request('viewCreate', IDENTITY),
                get: this.request('viewGet', IDENTITY),
                global: this.request('viewGlobal', IDENTITY),
                subgraph: this.request('viewSubgraph', IDENTITY),
                dryRun: this.request('viewDryRun', IDENTITY),
            },
            data: this.request('data', IDENTITY),
            alias: {
                add: this.request('aliasAdd', IDENTITY),
                remove: this.request('aliasRemove', IDENTITY),
            },
        };
        this.client = new graphql_request_1.GraphQLClient(url);
        this._sessionKey = sessionKey;
        this._sdk = g.getSdk(this.client);
    }
    /**
     * Generates a type-safe GraphQL query based on the auto-generated SDK function and a destructuring extract function.
     */
    request(fn, extract) {
        return (...variables) => __awaiter(this, void 0, void 0, function* () {
            const headers = getHeaders(new Headers({ Authorization: this._sessionKey }), variables[1]);
            const result = yield this._sdk[fn](...[variables[0], headers]);
            return extract(result, variables);
        });
    }
}
exports.TimegraphClient = TimegraphClient;
