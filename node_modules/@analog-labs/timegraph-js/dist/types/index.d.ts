import { Sdk, UserListQuery, UserCreateMutation, UserGetQuery, FunctionCreateMutation, SmartContractGetQuery, FunctionInfoFragmentFragment, SmartContractListFragmentFragment, ViewInfoFragmentFragment, ViewCreateMutation, ApiKeyListQuery, ApiKeyInfoFragment, ViewDryRunMutation, QueryResult, AliasResult, ListSmartContractMutation, DryRunListSmartContractMutation, WithdrawTokensMutation, SponsorViewMutation, GlobalStatsQuery, UserStatsQuery, SskStatsQuery, ViewStatsQuery, UserGraphQuery, ViewGraphQuery, SskGraphQuery, ViewFundLogQuery, UserFundedViewsQuery, BalanceHistoryQuery, TotalContractsQuery, TotalViewsQuery } from '../gql';
export * from '../gql';
export interface TimegraphClientOptions {
    url: string;
    sessionKey: string;
    rawResponse?: boolean;
}
export type SdkRequest<T extends keyof Sdk, U = Awaited<ReturnType<Sdk[T]>>> = (...variables: Parameters<Sdk[T]>) => Promise<U>;
export type DataArgs = {
    hashId: string;
    fields: string[];
    limit?: number;
};
export type MergeResult<ResultType> = {
    status: 'SUCCESS' | 'ERROR' | 'DUPLICATE';
    error?: string;
    result: ResultType;
};
export type UserCreate = UserCreateMutation['createAccount'];
export type UserGet = UserGetQuery['userInfo'];
export type UserList = UserListQuery['users'];
export type FnCreate = FunctionCreateMutation['merge']['functions'][0]['function'][] | null;
export type FnGet = FunctionInfoFragmentFragment;
export type FnList = FunctionInfoFragmentFragment[];
export type SmartContractGet = SmartContractGetQuery['global']['contracts'][0];
export type SmartContractGlobal = SmartContractListFragmentFragment[];
export type ListSmartContract = ListSmartContractMutation['contract'];
export type DryRunListSmartContract = DryRunListSmartContractMutation['contract'];
export type CollectionData = QueryResult;
export type ViewCreate = MergeResult<ViewCreateMutation['merge']['views'][0]['view']>[];
export type ViewDryRun = ViewDryRunMutation['merge']['views'];
export type ViewGet = ViewInfoFragmentFragment;
export type ViewGlobal = ViewInfoFragmentFragment[];
export type ViewSubgraph = ViewInfoFragmentFragment[];
export type ApiKeyList = ApiKeyListQuery['keys'];
export type ApiKeyInfo = ApiKeyInfoFragment;
export type TimegraphUser = {
    create: SdkRequest<'userCreate', UserCreate>;
    get: SdkRequest<'userGet', UserGet>;
    list: SdkRequest<'userList', UserList>;
};
export type TimegraphTokenomics = {
    widthdraw: SdkRequest<'withdrawTokens', WithdrawTokensMutation['withdrawToken']>;
    sponsorView: SdkRequest<'sponsorView', SponsorViewMutation['sponsorView']>;
};
export type TimegraphTelemetry = {
    global: SdkRequest<'GlobalStats', GlobalStatsQuery['global']>;
    user: SdkRequest<'UserStats', UserStatsQuery['global']>;
    userGraph: SdkRequest<'UserGraph', UserGraphQuery['global']>;
    balanceHistory: SdkRequest<'BalanceHistory', BalanceHistoryQuery['global']>;
    ssk: SdkRequest<'SSKStats', SskStatsQuery['global']>;
    sskGraph: SdkRequest<'SSKGraph', SskGraphQuery['global']>;
    view: SdkRequest<'ViewStats', ViewStatsQuery['global']>;
    viewGraph: SdkRequest<'ViewGraph', ViewGraphQuery['global']>;
    viewFundLog: SdkRequest<'ViewFundLog', ViewFundLogQuery['global']>;
    userFundedViews: SdkRequest<'UserFundedViews', UserFundedViewsQuery['global']>;
    totalContracts: SdkRequest<'TotalContracts', TotalContractsQuery['global']>;
    totalViews: SdkRequest<'TotalViews', TotalViewsQuery['global']>;
};
export type TimegraphApiKey = {
    list: SdkRequest<'apiKeyList', ApiKeyList>;
    certify: SdkRequest<'apiKeyCertify', ApiKeyInfo>;
    enable: SdkRequest<'apiKeyEnable', ApiKeyInfo>;
    disable: SdkRequest<'apiKeyDisable', ApiKeyInfo>;
    revoke: SdkRequest<'apiKeyRevoke', ApiKeyInfo>;
};
export type TimegraphFn = {
    create: SdkRequest<'functionCreate', FnCreate>;
    get: SdkRequest<'functionGet', FnGet>;
    global: SdkRequest<'functionGlobal', FnList>;
    subgraph: SdkRequest<'functionSubgraph', FnList>;
};
export type TimegraphSmartContract = {
    get: SdkRequest<'smartContractGet', SmartContractGet>;
    global: SdkRequest<'smartContractGlobal', SmartContractGlobal>;
    list: SdkRequest<'listSmartContract', ListSmartContract>;
    dryRun: SdkRequest<'dryRunListSmartContract', DryRunListSmartContract>;
};
export type TimegraphView = {
    create: SdkRequest<'viewCreate', ViewCreate>;
    dryRun: SdkRequest<'viewDryRun', ViewDryRun>;
    get: SdkRequest<'viewGet', ViewGet>;
    global: SdkRequest<'viewGlobal', ViewGlobal>;
    subgraph: SdkRequest<'viewSubgraph', ViewSubgraph>;
    data: <T>(_: DataArgs) => Promise<Array<T>>;
};
export type TimegraphAlias = {
    add: SdkRequest<'aliasAdd', AliasResult>;
    remove: SdkRequest<'aliasRemove', AliasResult>;
};
export type GeneratedApiKey = {
    key: string;
    secret: string;
    cert: string;
};
export type GeneratedSessionKey = {
    ssk: string;
};
export interface keygenOptionsWeb {
    signer: Signer['signRaw'];
    address: string;
}
export interface keygenOptionsNode {
    signer: IKeyringPair['sign'];
    address: string;
}
export type IKeyringPair = {
    sign: (data: Uint8Array, options?: SignOptions) => Uint8Array;
};
export interface Signer {
    /**
     * @description signs a raw payload, only the bytes data as supplied
     */
    signRaw?: (raw: SignerPayloadRaw) => Promise<SignerResult>;
}
export interface SignOptions {
    /**
     * @description Create a MultiSignature-compatible output with an indicator type
     **/
    withType?: boolean;
}
export interface SignerPayloadRawBase {
    /**
     * @description The hex-encoded data for this request
     */
    data: string;
    /**
     * @description The type of the contained data
     */
    type?: 'bytes' | 'payload';
}
export interface SignerPayloadRaw extends SignerPayloadRawBase {
    /**
     * @description The ss-58 encoded address
     */
    address: string;
    /**
     * @description The type of the contained data
     */
    type: 'bytes' | 'payload';
}
export interface SignerResult {
    /**
     * @description The id for this request
     */
    id: number;
    /**
     * @description The resulting signature in hex
     */
    signature: HexString;
}
export type HexString = `0x${string}`;
//# sourceMappingURL=index.d.ts.map